diff --git a/configuration/configuration.go b/configuration/configuration.go
index 35d9f435..85793dcd 100644
--- a/configuration/configuration.go
+++ b/configuration/configuration.go
@@ -656,6 +656,11 @@ type Proxy struct {
 
 	// LocalPathAlias renames the remote path to allow access to the registry via a local path alias
 	LocalPathAlias string `yaml:"localpathalias"`
+
+	// TTL is the expiry time of the content and will be cleaned up when it expires
+	// if not set, defaults to 7 * 24 hours
+	// If set to zero, will never expire cache
+	TTL *time.Duration `yaml:"ttl,omitempty"`
 }
 
 // Parse parses an input configuration yaml document into a Configuration struct
diff --git a/registry/handlers/app.go b/registry/handlers/app.go
index 5df96a37..946a0e43 100644
--- a/registry/handlers/app.go
+++ b/registry/handlers/app.go
@@ -319,14 +319,8 @@ func NewApp(ctx context.Context, config *configuration.Configuration) *App {
 	}
 
 	// configure as a pull through cache
-	if config.Proxy.RemoteURL != "" {
-		app.registry, err = proxy.NewRegistryPullThroughCache(ctx, app.registry, app.driver, config.Proxy)
-		if err != nil {
-			panic(err.Error())
-		}
-		app.isCache = true
-		dcontext.GetLogger(app).Info("Registry configured as a proxy cache to ", config.Proxy.RemoteURL)
-	} else {
+	if config.Proxy.RemoteURL == "" || (config.Proxy.TTL != nil && *config.Proxy.TTL <= 0) {
+		// Remove "/scheduler-state.json"
 		pathToStateFile := "/scheduler-state.json"
 		if _, err := app.driver.Stat(ctx, pathToStateFile); err != nil {
 			switch err := err.(type) {
@@ -340,6 +334,14 @@ func NewApp(ctx context.Context, config *configuration.Configuration) *App {
 			}
 		}
 	}
+	if config.Proxy.RemoteURL != "" {
+		app.registry, err = proxy.NewRegistryPullThroughCache(ctx, app.registry, app.driver, config.Proxy)
+		if err != nil {
+			panic(err.Error())
+		}
+		app.isCache = true
+		dcontext.GetLogger(app).Info("Registry configured as a proxy cache to ", config.Proxy.RemoteURL)
+	}
 	var ok bool
 	app.repoRemover, ok = app.registry.(distribution.RepositoryRemover)
 	if !ok {
diff --git a/registry/proxy/proxyblobstore.go b/registry/proxy/proxyblobstore.go
index cd7db713..99b4f6af 100644
--- a/registry/proxy/proxyblobstore.go
+++ b/registry/proxy/proxyblobstore.go
@@ -6,6 +6,7 @@ import (
 	"net/http"
 	"strconv"
 	"sync"
+	"time"
 
 	"github.com/distribution/reference"
 	"github.com/docker/distribution"
@@ -18,6 +19,7 @@ type proxyBlobStore struct {
 	localStore           distribution.BlobStore
 	remoteStore          distribution.BlobService
 	scheduler            *scheduler.TTLExpirationScheduler
+	ttl                  *time.Duration
 	localRepositoryName  reference.Named
 	remoteRepositoryName reference.Named
 	authChallenger       authChallenger
@@ -147,7 +149,11 @@ func (pbs *proxyBlobStore) ServeBlob(ctx context.Context, w http.ResponseWriter,
 			return
 		}
 
-		pbs.scheduler.AddBlob(blobRef, repositoryTTL)
+		if pbs.scheduler != nil && pbs.ttl != nil {
+			if err := pbs.scheduler.AddBlob(blobRef, *pbs.ttl); err != nil {
+				dcontext.GetLogger(ctx).Errorf("Error adding blob: %s", err)
+			}
+		}
 	}(dgst)
 
 	_, err = pbs.copyContent(ctx, dgst, w)
diff --git a/registry/proxy/proxyblobstore_test.go b/registry/proxy/proxyblobstore_test.go
index 26a4aecc..2a343312 100644
--- a/registry/proxy/proxyblobstore_test.go
+++ b/registry/proxy/proxyblobstore_test.go
@@ -180,7 +180,7 @@ func makeTestEnv(t *testing.T, localName, remoteName string) *testEnv {
 		blobs: localRepo.Blobs(ctx),
 	}
 
-	s := scheduler.New(ctx, localDriver, localRegistry, "/scheduler-state.json")
+	s := scheduler.New(ctx, 24*7*time.Hour, localDriver, localRegistry, "/scheduler-state.json")
 
 	proxyBlobStore := proxyBlobStore{
 		localRepositoryName:  localNameRef,
diff --git a/registry/proxy/proxymanifeststore.go b/registry/proxy/proxymanifeststore.go
index c5bb814a..6c1e07f7 100644
--- a/registry/proxy/proxymanifeststore.go
+++ b/registry/proxy/proxymanifeststore.go
@@ -11,9 +11,6 @@ import (
 	"github.com/opencontainers/go-digest"
 )
 
-// todo(richardscothern): from cache control header or config
-const repositoryTTL = 24 * 7 * time.Hour
-
 type proxyManifestStore struct {
 	ctx                  context.Context
 	localManifests       distribution.ManifestService
@@ -21,6 +18,7 @@ type proxyManifestStore struct {
 	localRepositoryName  reference.Named
 	remoteRepositoryName reference.Named
 	scheduler            *scheduler.TTLExpirationScheduler
+	ttl                  *time.Duration
 	authChallenger       authChallenger
 }
 
@@ -78,10 +76,13 @@ func (pms proxyManifestStore) Get(ctx context.Context, dgst digest.Digest, optio
 			return nil, err
 		}
 
-		pms.scheduler.AddManifest(repoBlob, repositoryTTL)
+		if pms.scheduler != nil && pms.ttl != nil {
+			if err := pms.scheduler.AddManifest(repoBlob, *pms.ttl); err != nil {
+				dcontext.GetLogger(ctx).Errorf("Error adding manifest: %s", err)
+			}
+		}
 		// Ensure the manifest blob is cleaned up
 		//pms.scheduler.AddBlob(blobRef, repositoryTTL)
-
 	}
 
 	return manifest, err
diff --git a/registry/proxy/proxymanifeststore_test.go b/registry/proxy/proxymanifeststore_test.go
index e656e121..c78e5dcc 100644
--- a/registry/proxy/proxymanifeststore_test.go
+++ b/registry/proxy/proxymanifeststore_test.go
@@ -5,6 +5,7 @@ import (
 	"io"
 	"sync"
 	"testing"
+	"time"
 
 	"github.com/distribution/reference"
 	"github.com/docker/distribution"
@@ -140,7 +141,7 @@ func newManifestStoreTestEnv(t *testing.T, localName, remoteName, tag string) *m
 		stats:     make(map[string]int),
 	}
 
-	s := scheduler.New(ctx, inmemory.New(), localRegistry, "/scheduler-state.json")
+	s := scheduler.New(ctx, 24*7*time.Hour, inmemory.New(), localRegistry, "/scheduler-state.json")
 	return &manifestStoreTestEnv{
 		manifestDigest: manifestDigest,
 		manifests: proxyManifestStore{
diff --git a/registry/proxy/proxyregistry.go b/registry/proxy/proxyregistry.go
index d861c893..16b3c05f 100644
--- a/registry/proxy/proxyregistry.go
+++ b/registry/proxy/proxyregistry.go
@@ -7,6 +7,7 @@ import (
 	"net/url"
 	"strings"
 	"sync"
+	"time"
 
 	"github.com/distribution/reference"
 	"github.com/docker/distribution"
@@ -21,10 +22,13 @@ import (
 	"github.com/docker/distribution/registry/storage/driver"
 )
 
+var repositoryTTL = 24 * 7 * time.Hour
+
 // proxyingRegistry fetches content from a remote registry and caches it locally
 type proxyingRegistry struct {
 	embedded       distribution.Namespace // provides local registry functionality
 	scheduler      *scheduler.TTLExpirationScheduler
+	ttl            *time.Duration
 	remoteURL      url.URL
 	authChallenger authChallenger
 	remotePathOnly string
@@ -48,62 +52,76 @@ func NewRegistryPullThroughCache(ctx context.Context, registry distribution.Name
 		return nil, err
 	}
 
+	var s *scheduler.TTLExpirationScheduler
+	var ttl *time.Duration
+	if config.TTL == nil {
+		// Default TTL is 7 days
+		ttl = &repositoryTTL
+	} else if *config.TTL > 0 {
+		ttl = config.TTL
+	} else {
+		// TTL is disabled, never expire
+		ttl = nil
+	}
+
 	v := storage.NewVacuum(ctx, driver)
-	s := scheduler.New(ctx, driver, registry, "/scheduler-state.json")
-	s.OnBlobExpire(func(ref reference.Reference) error {
-		var r reference.Canonical
-		var ok bool
-		if r, ok = ref.(reference.Canonical); !ok {
-			return fmt.Errorf("unexpected reference type : %T", ref)
-		}
+	if ttl != nil {
+		s = scheduler.New(ctx, *ttl, driver, registry, "/scheduler-state.json")
+		s.OnBlobExpire(func(ref reference.Reference) error {
+			var r reference.Canonical
+			var ok bool
+			if r, ok = ref.(reference.Canonical); !ok {
+				return fmt.Errorf("unexpected reference type : %T", ref)
+			}
 
-		repo, err := registry.Repository(ctx, r)
-		if err != nil {
-			return err
-		}
+			repo, err := registry.Repository(ctx, r)
+			if err != nil {
+				return err
+			}
 
-		blobs := repo.Blobs(ctx)
+			blobs := repo.Blobs(ctx)
 
-		// Clear the repository reference and descriptor caches
-		err = blobs.Delete(ctx, r.Digest())
-		if err != nil {
-			return err
-		}
+			// Clear the repository reference and descriptor caches
+			err = blobs.Delete(ctx, r.Digest())
+			if err != nil {
+				return err
+			}
 
-		err = v.RemoveBlob(r.Digest().String())
-		if err != nil {
-			return err
-		}
+			err = v.RemoveBlob(r.Digest().String())
+			if err != nil {
+				return err
+			}
 
-		return nil
-	})
+			return nil
+		})
 
-	s.OnManifestExpire(func(ref reference.Reference) error {
-		var r reference.Canonical
-		var ok bool
-		if r, ok = ref.(reference.Canonical); !ok {
-			return fmt.Errorf("unexpected reference type : %T", ref)
-		}
+		s.OnManifestExpire(func(ref reference.Reference) error {
+			var r reference.Canonical
+			var ok bool
+			if r, ok = ref.(reference.Canonical); !ok {
+				return fmt.Errorf("unexpected reference type : %T", ref)
+			}
 
-		repo, err := registry.Repository(ctx, r)
-		if err != nil {
-			return err
-		}
+			repo, err := registry.Repository(ctx, r)
+			if err != nil {
+				return err
+			}
 
-		manifests, err := repo.Manifests(ctx)
-		if err != nil {
-			return err
-		}
-		err = manifests.Delete(ctx, r.Digest())
+			manifests, err := repo.Manifests(ctx)
+			if err != nil {
+				return err
+			}
+			err = manifests.Delete(ctx, r.Digest())
+			if err != nil {
+				return err
+			}
+			return nil
+		})
+
+		err = s.Start()
 		if err != nil {
-			return err
+			return nil, err
 		}
-		return nil
-	})
-
-	err = s.Start()
-	if err != nil {
-		return nil, err
 	}
 
 	cs, err := configureAuth(config.Username, config.Password, config.RemoteURL)
@@ -114,6 +132,7 @@ func NewRegistryPullThroughCache(ctx context.Context, registry distribution.Name
 	return &proxyingRegistry{
 		embedded:       registry,
 		scheduler:      s,
+		ttl:            ttl,
 		remoteURL:      *remoteURL,
 		remotePathOnly: remotePathOnly,
 		localPathAlias: localPathAlias,
@@ -186,6 +205,7 @@ func (pr *proxyingRegistry) Repository(ctx context.Context, name reference.Named
 			localStore:           localRepo.Blobs(ctx),
 			remoteStore:          remoteRepo.Blobs(ctx),
 			scheduler:            pr.scheduler,
+			ttl:                  pr.ttl,
 			localRepositoryName:  localRepositoryName,
 			remoteRepositoryName: remoteRepositoryName,
 			authChallenger:       pr.authChallenger,
@@ -197,6 +217,7 @@ func (pr *proxyingRegistry) Repository(ctx context.Context, name reference.Named
 			remoteManifests:      remoteManifests,
 			ctx:                  ctx,
 			scheduler:            pr.scheduler,
+			ttl:                  pr.ttl,
 			authChallenger:       pr.authChallenger,
 		},
 		localRepositoryName: localRepositoryName,
diff --git a/registry/proxy/scheduler/scheduler.go b/registry/proxy/scheduler/scheduler.go
index 5f66d409..32341808 100644
--- a/registry/proxy/scheduler/scheduler.go
+++ b/registry/proxy/scheduler/scheduler.go
@@ -23,8 +23,6 @@ const (
 	indexSaveFrequency = 5 * time.Second
 )
 
-var repositoryTTL = 24 * 7 * time.Hour // TTL of repository objects (1 week)
-
 // schedulerEntry represents an entry in the scheduler
 // fields are exported for serialization
 type schedulerEntry struct {
@@ -36,9 +34,10 @@ type schedulerEntry struct {
 }
 
 // New returns a new instance of the scheduler
-func New(ctx context.Context, driver driver.StorageDriver, registry distribution.Namespace, path string) *TTLExpirationScheduler {
+func New(ctx context.Context, ttl time.Duration, driver driver.StorageDriver, registry distribution.Namespace, path string) *TTLExpirationScheduler {
 	return &TTLExpirationScheduler{
 		entries:         make(map[string]*schedulerEntry),
+		ttl:             ttl,
 		registry:        registry,
 		driver:          driver,
 		pathToStateFile: path,
@@ -59,6 +58,7 @@ type TTLExpirationScheduler struct {
 	registry        distribution.Namespace
 	driver          driver.StorageDriver
 	ctx             context.Context
+	ttl             time.Duration
 	pathToStateFile string
 
 	stopped bool
@@ -397,12 +397,12 @@ func (ttles *TTLExpirationScheduler) fillStateFromStorage() error {
 	defer ttles.Unlock()
 	// Schedule TTL for all tracked manifests
 	for manifestRef := range manifestRefSet {
-		ttles.add(manifestRef, repositoryTTL, entryTypeManifest)
+		ttles.add(manifestRef, ttles.ttl, entryTypeManifest)
 	}
 
 	// Schedule TTL for all tracked blobs
 	for blobRef := range blobRefSet {
-		ttles.add(blobRef, repositoryTTL, entryTypeBlob)
+		ttles.add(blobRef, ttles.ttl, entryTypeBlob)
 	}
 	return nil
 }
diff --git a/registry/proxy/scheduler/scheduler_test.go b/registry/proxy/scheduler/scheduler_test.go
index 0240a428..725512b7 100644
--- a/registry/proxy/scheduler/scheduler_test.go
+++ b/registry/proxy/scheduler/scheduler_test.go
@@ -13,7 +13,7 @@ import (
 	distribution_context "github.com/docker/distribution/context"
 	"github.com/docker/distribution/registry/storage"
 	"github.com/docker/distribution/registry/storage/cache/memory"
-	"github.com/docker/distribution/registry/storage/driver"
+	storagedriver "github.com/docker/distribution/registry/storage/driver"
 	"github.com/docker/libtrust"
 
 	// "github.com/docker/distribution/registry/storage/driver/filesystem"
@@ -29,7 +29,7 @@ type schedulerEntryTest struct {
 	EntryType int `json:"EntryType"`
 }
 
-func newRegistry(t *testing.T) (driver.StorageDriver, distribution.Namespace) {
+func newRegistry(t *testing.T) (storagedriver.StorageDriver, distribution.Namespace) {
 	ctx := distribution_context.Background()
 	k, err := libtrust.GenerateECP256PrivateKey()
 	if err != nil {
@@ -157,6 +157,7 @@ func testRefs(t *testing.T) (reference.Reference, reference.Reference, reference
 
 func TestSchedule(t *testing.T) {
 	driver, registry := newRegistry(t)
+	ttl := 24 * 7 * time.Hour
 
 	ref1, ref2, ref3 := testRefs(t)
 	timeUnit := time.Millisecond
@@ -167,7 +168,7 @@ func TestSchedule(t *testing.T) {
 	}
 
 	var mu sync.Mutex
-	s := New(context.Background(), driver, registry, "/ttl")
+	s := New(context.Background(), ttl, driver, registry, "/ttl")
 	deleteFunc := func(repoName reference.Reference) error {
 		if len(remainingRepos) == 0 {
 			t.Fatalf("Incorrect expiry count")
@@ -211,6 +212,7 @@ func TestSchedule(t *testing.T) {
 
 func TestRestoreOld(t *testing.T) {
 	driver, registry := newRegistry(t)
+	ttl := 24 * 7 * time.Hour
 
 	ref1, ref2, _ := testRefs(t)
 	remainingRepos := map[string]bool{
@@ -259,7 +261,7 @@ func TestRestoreOld(t *testing.T) {
 	if err != nil {
 		t.Fatal("Unable to write serialized data to fs")
 	}
-	s := New(context.Background(), driver, registry, "/ttl")
+	s := New(context.Background(), ttl, driver, registry, "/ttl")
 	s.OnBlobExpire(deleteFunc)
 	err = s.Start()
 	if err != nil {
@@ -297,6 +299,7 @@ func TestStoreState(t *testing.T) {
 	ctx := context.Background()
 	driver, registry := newRegistry(t)
 	v := storage.NewVacuum(ctx, driver)
+	ttl := 24 * 7 * time.Hour
 
 	// Create img1, img2, img3
 	manifestRef1, blobsRef1 := populateRepo(ctx, t, registry, "test", "latest", 1)
@@ -379,7 +382,7 @@ func TestStoreState(t *testing.T) {
 	}
 
 	// Start sheduler
-	s := New(context.Background(), driver, registry, pathToStatFile)
+	s := New(context.Background(), ttl, driver, registry, pathToStatFile)
 	s.OnBlobExpire(onBlobExpire)
 	s.OnManifestExpire(onManifestExpire)
 	err = s.Start()
@@ -388,9 +391,9 @@ func TestStoreState(t *testing.T) {
 	}
 
 	// Add img3 (Expiry after repositoryTTL time)
-	s.AddManifest(manifestRef3, repositoryTTL)
+	s.AddManifest(manifestRef3, ttl)
 	for _, blob := range blobsRef3 {
-		s.AddBlob(blob, repositoryTTL)
+		s.AddBlob(blob, ttl)
 	}
 
 	// Wait Expiry img1 and img2, and save state file in storage
@@ -424,6 +427,7 @@ func TestStoreState(t *testing.T) {
 
 func TestStopRestore(t *testing.T) {
 	driver, registry := newRegistry(t)
+	ttl := 24 * 7 * time.Hour
 
 	ref1, ref2, _ := testRefs(t)
 
@@ -442,7 +446,7 @@ func TestStopRestore(t *testing.T) {
 	}
 
 	pathToStateFile := "/ttl"
-	s := New(context.Background(), driver, registry, pathToStateFile)
+	s := New(context.Background(), ttl, driver, registry, pathToStateFile)
 	s.onBlobExpire = deleteFunc
 
 	err := s.Start()
@@ -458,7 +462,7 @@ func TestStopRestore(t *testing.T) {
 	time.Sleep(10 * time.Millisecond)
 
 	// v2 will restore state from fs
-	s2 := New(context.Background(), driver, registry, pathToStateFile)
+	s2 := New(context.Background(), ttl, driver, registry, pathToStateFile)
 	s2.onBlobExpire = deleteFunc
 	err = s2.Start()
 	if err != nil {
@@ -478,15 +482,7 @@ func TestFillStateFromStorageExpireState(t *testing.T) {
 	var mu sync.Mutex
 	timeUnit := time.Millisecond
 	pathToStatFile := "/ttl"
-	saveRepositoryTTL := 10 * timeUnit
-
-	swapTTL := func() {
-		saveRepositoryTTL, repositoryTTL = repositoryTTL, saveRepositoryTTL
-	}
-	swapTTL()
-	defer func() {
-		swapTTL()
-	}()
+	ttl := 10 * timeUnit
 
 	allManifests := map[reference.Canonical]struct{}{}
 	allBlobs := map[reference.Canonical]struct{}{}
@@ -552,7 +548,7 @@ func TestFillStateFromStorageExpireState(t *testing.T) {
 	}
 
 	// Start sheduler with empty state, expected startFiller
-	s := New(context.Background(), driver, registry, pathToStatFile)
+	s := New(context.Background(), ttl, driver, registry, pathToStatFile)
 	s.OnBlobExpire(onBlobExpire)
 	s.OnManifestExpire(onManifestExpire)
 	err := s.Start()
@@ -577,15 +573,7 @@ func TestFillStateFromStorageExpireState(t *testing.T) {
 
 func TestFillStateFromStorageStoreState(t *testing.T) {
 	pathToStatFile := "/ttl"
-	saveRepositoryTTL := 10000 * time.Hour
-
-	swapTTL := func() {
-		saveRepositoryTTL, repositoryTTL = repositoryTTL, saveRepositoryTTL
-	}
-	swapTTL()
-	defer func() {
-		swapTTL()
-	}()
+	ttl := 10000 * time.Hour
 
 	ctx := context.Background()
 	driver, registry := newRegistry(t)
@@ -649,7 +637,7 @@ func TestFillStateFromStorageStoreState(t *testing.T) {
 	}
 
 	// Start sheduler with empty state, expected startFiller
-	s := New(context.Background(), driver, registry, pathToStatFile)
+	s := New(context.Background(), ttl, driver, registry, pathToStatFile)
 	s.OnBlobExpire(onBlobExpire)
 	s.OnManifestExpire(onManifestExpire)
 	err := s.Start()
@@ -689,15 +677,7 @@ func TestFillStateFromStorageStoreState(t *testing.T) {
 func TestFillStateFromStorageStoreAndUpdateState(t *testing.T) {
 	timeUnit := time.Millisecond
 	pathToStatFile := "/ttl"
-	saveRepositoryTTL := 10000 * timeUnit
-
-	swapTTL := func() {
-		saveRepositoryTTL, repositoryTTL = repositoryTTL, saveRepositoryTTL
-	}
-	swapTTL()
-	defer func() {
-		swapTTL()
-	}()
+	ttl := 10000 * timeUnit
 
 	ctx := context.Background()
 	driver, registry := newRegistry(t)
@@ -761,7 +741,7 @@ func TestFillStateFromStorageStoreAndUpdateState(t *testing.T) {
 	}
 
 	// Start and stop sheduler with empty state, expected startFiller
-	s1 := New(context.Background(), driver, registry, pathToStatFile)
+	s1 := New(context.Background(), ttl, driver, registry, pathToStatFile)
 	s1.OnBlobExpire(onBlobExpire)
 	s1.OnManifestExpire(onManifestExpire)
 	err := s1.Start()
@@ -781,7 +761,7 @@ func TestFillStateFromStorageStoreAndUpdateState(t *testing.T) {
 	manifestRef, blobsRef := populateRepo(ctx, t, registry, "f/g/h", "latest", 2)
 
 	// Start and stop sheduler with not empty state, not expected startFiller
-	s2 := New(context.Background(), driver, registry, pathToStatFile)
+	s2 := New(context.Background(), ttl, driver, registry, pathToStatFile)
 	s2.OnBlobExpire(onBlobExpire)
 	s2.OnManifestExpire(onManifestExpire)
 	err = s2.Start()
@@ -803,7 +783,7 @@ func TestFillStateFromStorageStoreAndUpdateState(t *testing.T) {
 	}
 
 	// Create the third scheduler
-	s3 := New(context.Background(), driver, registry, pathToStatFile)
+	s3 := New(context.Background(), ttl, driver, registry, pathToStatFile)
 	s3.OnBlobExpire(onBlobExpire)
 	s3.OnManifestExpire(onManifestExpire)
 	err = s3.Start()
@@ -812,9 +792,9 @@ func TestFillStateFromStorageStoreAndUpdateState(t *testing.T) {
 	}
 
 	// Add data to the scheduler with new img4
-	s3.AddManifest(manifestRef, repositoryTTL)
+	s3.AddManifest(manifestRef, ttl)
 	for _, blob := range blobsRef {
-		s3.AddBlob(blob, repositoryTTL)
+		s3.AddBlob(blob, ttl)
 	}
 
 	<-time.After(100 * timeUnit)
@@ -834,8 +814,9 @@ func TestFillStateFromStorageStoreAndUpdateState(t *testing.T) {
 
 func TestDoubleStart(t *testing.T) {
 	driver, registry := newRegistry(t)
+	ttl := 24 * 7 * time.Hour
 
-	s := New(context.Background(), driver, registry, "/ttl")
+	s := New(context.Background(), ttl, driver, registry, "/ttl")
 	err := s.Start()
 	if err != nil {
 		t.Fatalf("Unable to start scheduler")
