modules/150-user-authn/docs/USAGE_RU.md



1. Создать новый проект в Deckhouse.
2. Подключиться к проекту.
3. Настроить подключение к кластеру Kubernetes.
4. Запустить необходимые приложения и сервисы, используя Deckhouse как платформу для управления и автоматизации развертывания приложений.
5. Настроить аутентификацию и авторизацию для доступа к Deckhouse, используя встроенные механизмы аутентификации или внешние системы управления доступом, такие как LDAP, Active Directory...

Для аутентификации:

Для настройки аутентификации в Deckhouse пользователю необходимо выполнить следующие действия (команды для примера):

* Создать учетную запись для аутентификации с помощью команды deckhouse user create.
* Настроить аутентификацию с использованием LDAP, Active Directory, или другой системы аутентификации с помощью команд deckhouse auth ldap configure или deckhouse auth active-directory configure соответственно.
* Задать параметры аутентификации для Deckhouse через конфигурационный файл или с помощью команд deckhouse config ldap set и deckhouse config active-directory set соответственно.
* Разрешить использование аутентификации на уровне кластера Kubernetes с помощью команды kubectl auth can-i.
* Назначить права доступа пользователям и группам с помощью команд kubectl auth reconcile и kubectl auth add-scope.
* Протестировать аутентификацию, используя команду deckhouse auth test.
* Обновить конфигурацию кластера Kubernetes с использованием команды kubectl apply.
* Переподключиться к кластеру с помощью команды deckhouse connect.
* Убедиться, что аутентификация работает корректно, используя команды kubectl get secrets и kubectl describe secret.

Изначально администратор входит при помощи токена под логином сервисного аккаунта. Идентификатор администратора - сервисный аккаунт, при установке кластера и с правами администратора кластера. Сервисные аккаунты могут объединяться в кластерные роли. Администратор создает кластер при помощи файла **kubeconfig** и раздает его пользователям (администратор назначает им роли), которые могут пользоваться только предоставленным кластером. Управление доступом производится на основе ролей (RBAC) — это метод регулирования доступа к компьютерам и сетевым ресурсам, опирающийся на роли отдельных пользователей. RBAC можно использовать со всеми ресурсами DKP, которые поддерживают CRUD (Create, Read, Update, Delete).

Администратором DKP является привилегированный пользователь ОС (см. официальную документацию к продуктам, указанным в Руководстве по установке в разделе «Системные требования»), добавленный в группу wheel. Он же устанавливает кластер.

Во всех кластерах DKP есть две категории пользователей: учетные записи служб, управляемые DKP (Service Accounts), и пользователи (Users), управляемые внешними, независимыми сервисами.

Предполагается, что независимая от кластера служба управляет обычными пользователями следующими способами:

* администратором, распространяющим закрытые ключи;

* хранилищем пользователей;

* файлом со списком имен пользователей и паролей.

В связи с этим в DKP нет объектов, которые представляют обычные учетные записи пользователей. Обычных пользователей нельзя добавить в кластер с помощью вызова API.

Даже если обычный пользователь не добавлен с помощью вызова API, любой пользователь, который представляет действительный сертификат, подписанный центром сертификации кластера (CA), считается аутентифицированным. В этой конфигурации DKP определяет имя пользователя из общего поля имени в «теме» сертификата (например, "/CN=bob"). Оттуда подсистема управления доступом на основе ролей (RBAC) определит, авторизован ли пользователь для выполнения определенной операции с ресурсом.

В отличие от этого, учетные записи служб - это пользователи, управляемые API DKP. Они привязаны к определенным пространствам имен и создаются автоматически сервером API или вручную с помощью вызовов API. Учетные записи служб привязаны к набору учетных данных, хранящихся как Secrets, которые монтируются в pods, позволяющие процессам внутри кластера взаимодействовать с API DKP.

**Примечание:** запросы API привязаны либо к обычному пользователю, либо к учетной записи службы, либо рассматриваются как анонимный запрос. Это означает, что каждый процесс внутри или за пределами кластера должен проходить аутентификацию при отправке запросов на сервер API.

Основное отличие этих типов в том, что для учетной записи служб (Service Accounts) существуют специальные объекты в DKP API (они называются — ServiceAccounts), которые привязаны к пространству имен и набору авторизационных данных, хранящихся в кластере в объектах типа Secrets. Такие пользователи учетных записей служб (Service Accounts) предназначены в основном для управления правами доступа к DKP API процессов, работающих в кластере DKP.

Users не имеют записей в DKP API: управление ими должно осуществляться внешними механизмами. Они предназначены для процессов вне кластера.

Каждый запрос к API привязан либо к Service Account, либо к User, либо считается анонимным.

В DKP администратором назначаются следующие роли:

* view: доступ только для чтения, исключает секреты;

* edit: перечисленное выше + возможность редактировать большинство ресурсов, исключает роли и привязки ролей;

* admin: перечисленное выше + возможность управлять ролями и привязками ролей на уровне пространств имен;

* cluster-admin: все возможные привилегии.

Помимо этого в DKP присутствует два типа пользователей-администраторов:

* Service Accounts — аккаунты, управляемые DKP API;

* Users — пользователи, управляемые внешними, независимыми сервисами.

Основное отличие этих типов в том, что для Service Accounts существуют специальные объекты в DKP API (они называются — ServiceAccounts), которые привязаны к пространству имен и набору авторизационных данных. Такие пользователи (Service Accounts) предназначены в основном для управления правами доступа к DKP API процессов, работающих в кластере DKP.

Users не имеют записей в DKP API: управление ими должно осуществляться внешними механизмами. Они предназначены для процессов вне кластера.

Каждый запрос к API привязан либо к Service Account, либо к User, либо считается анонимным.

Аутентификационные данные пользователя включают в себя:

* **Username** — имя пользователя (зависит от регистра);

* **UID (User ID)** — идентификатор пользователя, сгенерированный по стандарту UUID (Universally Unique Identifier или универсальный уникальный идентификатор);

* **Groups** — список групп, к которым принадлежит пользователь;

* **Extra** — дополнительные поля, которые могут быть использованы механизмом авторизации.

UUID представляет собой 16-байтный (128-битный) номер. UUID изображают в виде числа в шестнадцатеричной системе счисления, разделенного дефисами на пять групп в формате 8-4-4-4-12, что в итоге составляет 36 символов.

Пример UUID:

~~~

123e4567-e89b-12d3-a456-426655440000
xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx

~~~

где 4 бита M обозначают версию («version») UUID, а 1-3 старших бита N обозначают вариант («variant») UUID.

DKP может использовать разные механизмы аутентификации: сертификаты, bearer-токены, аутентифицирующий прокси, HTTP Basic Auth. При помощи этих механизмов можно реализовать большое количество схем авторизации: от статичного файла с паролями до OpenID OAuth2.

По умолчанию в кластере используются service account tokens — для Service Accounts.

Сервер API концептуально выполняет аутентификацию, используя одну из доступных стратегий, представленных подключаемыми модулями аутентификации.

Клиент предоставляет свои учетные данные серверу API.
Сервер API использует один из настроенных подключаемых модулей аутентификации (можно включить несколько) для установления подлинности у поставщика удостоверений.
Поставщик удостоверений создает, поддерживает и управляет сведениями об удостоверении, одновременно предоставляя приложениям службы проверки подлинности.
Если учетные данные в порядке, сервер API переходит к проверке разрешений. В противном случае он возвращает код ответа о состоянии ошибки неавторизованного клиента HTTP 401, и при этом запрос завершается неудачей.

Допускается использование нескольких схем авторизации одновременно. По умолчанию в кластере используются:

* service account tokens — для учетной записи служб (Service Accounts);

* сертификаты X509 — для Users, управляемых внешними, независимыми сервисами.

##Идентификация и аутентификация пользователей

### Имена и идентификаторы объектов

Каждый объект в кластере имеет имя, уникальное для данного типа ресурса. Каждый объект DKP также имеет UID, который уникален для всего кластера.

Например, может быть только один pod с именем **myapp** в пределах одного пространства имен, но может быть один pod и одно развертывание, каждое из которых имеет имя **myapp**.

Для неуникальных пользовательских атрибутов DKP предоставляет метки и примечания.

#### Имена

Предоставляемая клиентом строка, которая ссылается на объект в URL ресурса, например `/api/v1/pods/some-name`. Имена должны быть уникальными для всех версий API одного и того же ресурса. Ресурсы API различаются по их группе API, типу ресурса, пространству имен (для ресурсов с пространством имен) и имени. Другими словами, версия API в данном контексте не имеет значения.

**Примечание:** В случаях, когда объекты представляют физическую сущность, например, узел, представляющий физический узел, когда узел создается заново под тем же именем без удаления и повторного создания узла, DKP обрабатывает новый узел как старый, что может привести к несоответствиям.

Ниже приведены четыре типа часто используемых ограничений имен для ресурсов (объектов или операций) DKP.

**Имена поддоменов DNS (чтобы запущенные контейнеры DKP могли искать службы по имени, а не по IP)**

Для большинства типов ресурсов требуется имя, которое может использоваться в качестве имени поддомена DNS, как определено в RFC 1123. Это означает, что имя должно:

* содержать не более 253 символов;

* содержать только строчные буквенно-цифровые символы, **-** (дефис) или **.** (точка);

* начинаться с буквенно-цифрового символа;

* заканчиваться буквенно-цифровым символом.

**Имена меток RFC 1123 (чтобы неуникальные пользовательские атрибуты DKP предоставили метки по стандарту RFC 1123)**

Некоторые типы ресурсов требуют, чтобы их имена соответствовали стандарту меток DNS, определенному в RFC 1123. Это означает, что имя должно:

* содержать не более 63 символов;

* содержать только строчные буквенно-цифровые символы или **-** (дефис);

* начинаться с буквенно-цифрового символа;

* заканчиваться буквенно-цифровым символом.

**Имена меток RFC 1035 (чтобы неуникальные пользовательские атрибуты DKP предоставили метки по стандарту RFC 1035)**

Некоторые типы ресурсов требуют, чтобы их имена соответствовали стандарту меток DNS, определенному в RFC 1035. Это означает, что имя должно:

* содержать не более 63 символов;

* содержать только строчные буквенно-цифровые символы или **-** (дефис);

* начинаться с буквенного символа;

* заканчиваться буквенно-цифровым символом.

**Имена сегментов пути (чтобы безопасно кодировать имена, как сегмент пути)**

Некоторые типы ресурсов требуют, чтобы их имена можно было безопасно кодировать как сегмент пути. Другими словами, в имени могут отсутствовать значки: **.** (точка) или **..** (две точки) и имя может не содержать **/** (слеш) или **%** (значок процента).

Пример манифеста для pod с именем **nginx-demo** представлен ниже:

```
тут пример
```
### Идентификация и аутентификация при межсервисном (межмодульном) взаимодействии

#### Базовая аутентификация

Подобно bearer токенам, базовые пароли аутентификации не могут быть изменены без перезапуска сервера API.

* Токены начальной загрузки. Чтобы упростить загрузку для новых кластеров, DKP включает динамически управляемый тип токена-носителя, называемый токеном начальной загрузки. Эти токены хранятся, как секреты в пространстве имен **kube-system**, где ими можно динамически управлять. Диспетчер контроллеров содержит контроллер **TokenCleaner**, который удаляет токены начальной загрузки по мере истечения срока их действия.

* Токены учетной записи службы. Аутентификация учетной записи службы включается автоматически. Она проверяет подписанные токены на предъявителя. Ключ подписи задается с помощью `--service-account-key-file`. Учетные записи служб создаются **kube-apiserver** и связаны с pods.

* Прокси-сервер аутентификации. **kube-apiserver** может быть настроен для идентификации пользователей с использованием заголовка запроса X-Remote. Можно включить этот метод, добавив следующие аргументы на сервер API:

~~~

--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra

~~~

#### Аутентификация по умолчанию

По умолчанию аутентификация происходит следующим образом:

1. При развертке кластера kubeadm создает корневой центр сертификации для предоставления удостоверений для каждого компонента (включая узлы) в кластере. Он также генерирует клиентские сертификаты, которые будут использоваться различными компонентами.

2. По умолчанию настройки kubelet выглядят следующим образом:

~~~

authentication:
  anonymous:
    enabled: false
  webhook:
    cacheTTL: 0s
    enabled: true
  x509:
    clientCAFile: /etc/kubernetes/pki/ca.crt
authorization:
  mode: Webhook
  webhook:
    cacheAuthorizedTTL: 0s
    cacheUnauthorizedTTL: 0s

~~~

Таким образом, анонимный пользователь не сможет войти в кластер без сертификата.

### Использование объектов secret

Объекты secret (секреты) являются важнейшим элементом защиты системы. Секретами могут быть любые данные, требующие конфиденциальности. 
Например: 

* имя и пароль пользователя DKP; 

* токены доступа; 

* API-ключи;

* ключи шифрования.

Вышеприведенные примеры информации обычно не превышают 50-ти символов.

Если требуется защитить данные большого размера, рекомендуется зашифровать их и поместить соответствующий ключ в объект secret.

**Примечание:** Приведенные рекомендации по настройке парольной политики не должны противоречить требованиям внутренних документов Заказчика, отраслевых и национальных стандартов, требований уполномоченных регуляторов и законодательства РФ.

**Хранение объектов secret в DKP**

Существует возможность шифрования объектов secret через REST (если они хранятся в etcd). Управление объектами secret происходит на уровне пространства имен. К pods можно подключать через файлы, секретные тома или в качестве переменных окружения. С точки зрения безопасности это означает, что любые пользователи или сервисы, которые могут создать pod в определенном пространстве имен, имеют доступ ко всем объектам secret этого пространства. Если вы хотите сделать более строгим доступ к своему объекту, поместите последний в пространство имен с ограниченным набором пользователей или сервисов.

При подключении объекта secret к pod он помещается в **tmpfs** и никогда не записывается на диск. Для взаимодействия между **kubelet** и API-сервером обычно используется TLS 1.2, поэтому во время передачи объект secret находится в безопасности.

**Настройка шифрования для REST**

При запуске API-сервера укажите такой параметр:

~~~

--experimental-encryption-provider-config <имя файла с настройками шифрования>

~~~~

Далее приведен пример конфигурации шифрования:

~~~

kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - identity: {}
      - aesgcm:
          keys:
            - name: key1
              secret: I86skpfi23nfeOGdbkdw77==
            - name: key2
              secret: 8bTla13mbSglpl38w32pAB==
      - aescbc:
          keys:
            - name: key1
              secret: I86skpfi23nfeOGdbkdw77==
            - name: key2
              secret: 8bTla13mbSglpl38w32pAB==
      - secretbox:
          keys:
            - name: key1
              secret: lkjQj2gsUtB9xx0Ybj4laR8bn8rdPsXcmn265qgs9kf=
 
 ~~~

**Примечание:** ключи приведены для примера и являются несуществующими.

**Создание объектов secret**

Объекты secret должны быть готовы к моменту написания pod, который их использует, иначе этот процесс завершится неудачно. Объект secret можно создать с помощью следующей команды:

~~~

kubectl create secret
  
~~~

Cоздайте стандартный объект (в примере он имеет название **hush-hash**), который содержит два ключа — имя пользователя и пароль:

~~~

> kubectl create secret generic hush-hash --from-literal=username=tobias
-from-literal=password=cutoffs
# Готовый объект имеет тип Opaque:
> kubectl describe secrets/hush-hash
Name: hush-hash
Namespace: default
Labels: <none>
Annotations: <none>
Type: Opaque
Data
====
password: 7 bytes
username: 6 bytes

~~~

Чтобы создать объект secret из файла, укажите параметр `--from-file` вместо `--from-literal`. Это можно выполнить и вручную, если закодировать содержимое объекта в формате base64.

**Примечание:** Приведенные рекомендации по настройке парольной политики не должны противоречить требованиям внутренних документов Заказчика, отраслевых и национальных стандартов, требований уполномоченных регуляторов и законодательства РФ.

#### Стратегии аутентификации

DKP использует клиентские сертификаты, токены на предъявителя или аутентифицирующий прокси-сервер для аутентификации запросов API с помощью плагинов аутентификации. Когда HTTP-запросы отправляются на сервер API, плагины пытаются связать следующие атрибуты с запросом:

* Username: строка, которая идентифицирует конечного пользователя. Общими значениями могут быть kube-admin или `jane@example.com`.

* UID: строка, которая идентифицирует конечного пользователя и пытается быть более последовательной и уникальной, чем имя пользователя.

* Groups: набор строк, каждая из которых указывает членство пользователя в именованной логической коллекции пользователей. Общими значениями могут быть system:masters или devops-team.

* Extra: сопоставление строк со списком строк, который содержит дополнительную информацию.

Для DKP доступны механизмы аутентификации: 
 
* сертификаты X509; 

* Bearer-токены;

* аутентифицирующий прокси; 

* HTTP Basic Auth. 
 
Также допускается использование нескольких схем авторизации одновременно. По умолчанию в кластере используются аутентификация:

* service account tokens — для Service Accounts;

* X509 — для Users.

Интеграция с другими протоколами аутентификации (LDAP, SAML, Kerberos, альтернативные схемы x509 и т.д.) выполняется с использованием аутентифицирующего прокси.

##### Механизмы (плагины) аутентификации

**Сертификаты для пользователей X509**

Способ аутентификации по сертификату пользователя включается при передаче `--client-ca-file=SOMEFILE` опции серверу API. Файл должен содержать один или несколько центров сертификации, которые будут использоваться для проверки клиентских сертификатов, представленных серверу API. Если сертификат клиента представлен и проверен, в качестве имени пользователя для запроса используется общее имя субъекта. Чтобы включить членство в нескольких группах для пользователя, включите в сертификат несколько полей организации.

1. Например, с помощью **openssl** средства командной строки для создания запроса на подпись сертификата можно следующим образом:

~~~

openssl req -new -key maria.pem -out jbeda-csr.pem -subj "/CN=jbeda/O=app1/O=app2"

~~~

Это создаст запрос на подпись сертификата для имени пользователя maria, принадлежащего двум группам app1 и app2.

2. Создайте ключ для пользователя:

~~~

mkdir -p ~/mynewuser/.certs/
openssl genrsa -out ~/.certs/mynewuser.key 2048

~~~

3. Создайте запрос на сертификат:

~~~

openssl req -new -key ~/.certs/mynewuser.key -out ~/.certs/mynewuser.csr -subj "/CN=mynewuser/O=company"

~~~

4. Обработайте запрос на сертификат при помощи ключей CA кластера DKP, получение сертификата пользователя (для получения сертификата нужно использовать учетную запись, имеющую доступ к ключу центра сертификации кластера DKP, который по умолчанию находится в `/etc/DKP/pki/ca.key`):

~~~

openssl x509 -req -in ~/.certs/mynewuser.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out ~/.certs/mynewuser.crt -days 500

~~~

5. Создайте конфигурационный файл с описанием кластера (укажите адрес и расположение файла сертификата CA конкретной инсталляции кластера):

~~~

kubectl config set-cluster kubernetes --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://000.000.000.000:0000

~~~

6. Добавьте пользователя в конфигурационный файл:

~~~

kubectl config set-credentials mynewuser --client-certificate=.certs/mynewuser.crt  --client-key=.certs/mynewuser.key

~~~

7. Добавьте контекст:

~~~

kubectl config set-context mynewuser-context --cluster=kubernetes --namespace=target-namespace --user=mynewuser

~~~

8. Назначьте контекст по умолчанию:

~~~

kubectl config use-context mynewuser-context

~~~

После указанных выше манипуляций, в файле `.kube/config` будет создан конфигурационный файл следующего вида:

~~~

apiVersion: v1
clusters:
- cluster:
  certificate-authority: /etc/kubernetes/pki/ca.crt
  server: https://192.168.100.200:6443
  name: kubernetes
  contexts:
- context:
  cluster: kubernetes
  namespace: target-namespace
  user: mynewuser
  name: mynewuser-context
  current-context: mynewuser-context
  kind: Config
  preferences: {}
  users:
- name: mynewuser
  user:
  client-certificate: /home/mynewuser/.certs/mynewuser.crt
  client-key: /home/mynewuser/.certs/mynewuser.key

~~~

Отредактируйте значения ключей для удобства переноса конфигурационного файла между учетными записями и серверами:

~~~

certificate-authority
client-certificate
client-key

~~~

Закодируйте указанные в них файлы при помощи **base64** и пропишите их в конфигурационном файле, добавив в название ключей суффикс `-data`, получив `certificate-authority-data`.

**Клиент предоставляет свои учетные данные серверу API**

Сервер API использует один из настроенных подключаемых модулей аутентификации (можно включить несколько) для установления подлинности у поставщика удостоверений.

Поставщик удостоверений проверяет информацию запроса, включая имя пользователя и членство в группе.

Если учетные данные в порядке, сервер API переходит к проверке разрешений. В противном случае он возвращает код ответа о состоянии ошибки неавторизованного клиента HTTP 401, и при этом запрос завершается неудачей.

**Статический файл токена**

Сервер API считывает токены на предъявителя из файла при задании `--token-auth-file=SOMEFILE` опции в командной строке. Список токенов нельзя изменить без перезапуска сервера API.

Файл токена представляет собой CSV-файл, содержащий минимум 3 столбца: токен, имя пользователя, uid пользователя, за которыми следуют необязательные имена групп.

**Примечание:** Если содержится более одной группы, столбец должен быть заключен в двойные кавычки, например, `token,user,uid,"group1,group2,group3"`

**Добавление токена на предъявителя в запрос**

При использовании аутентификации токена на предъявителя от HTTP-клиента сервер API ожидает Authorization заголовок со значением Bearer <token>. Токен предъявителя должен представлять собой последовательность символов, которую можно поместить в значение заголовка HTTP, используя не более чем средства кодирования и цитирования HTTP. Например: если токен на предъявителя является 31a---269, то он будет отображаться в заголовке HTTP, как показано ниже.

~~~

Authorization: Bearer 31a---269

~~~

**Токены начальной загрузки**

Токен начальной загрузки - это простой токен на предъявителя, который предназначен для использования при создании новых кластеров или присоединении новых узлов к существующему кластеру. Токен начальной загрузки создается для поддержки kubeadm, но может использоваться в других контекстах для пользователей, которые хотят запускать кластеры без kubeadm. Также токен начальной загрузки был создан для работы с помощью политики RBAC с системой начальной загрузки Kubelet TLS 1.2. Эти токены хранятся как секреты в kube-system пространстве имен, где ими можно динамически управлять и создавать новые. Диспетчер контроллеров содержит контроллер TokenCleaner, который удаляет токены начальной загрузки по мере истечения срока их действия.

Токены имеют вид [a-z0-9]{6}.[a-z0-9]{16}.

Где: первый компонент - это идентификатор токена, а второй компонент - секрет токена. Необходимо указать токен в заголовке HTTP следующим образом:

~~~

Authorization: Bearer 781292.db7bc3a58fc5f07e

~~~

Аутентификация по токену начальной загрузки включается следующим образом: 

1. Установите флаг `--enable-bootstrap-token-auth` на сервере API. 

2. Включите контроллер TokenCleaner с помощью флага `--controllers` в диспетчере контроллеров. Это будет выглядеть примерно так: `--controllers=*,tokencleaner`. 

**Примечание:** инструмент **kubeadm** произведет настройку токена самостоятельно, если его использовать для начальной загрузки кластера.

Аутентификатор выполняет аутентификацию как `system:bootstrap:<Token ID>`. Он включен в группу `system:bootstrappers`. Именование и группы намеренно ограничены, чтобы препятствовать пользователям использовать эти токены после начальной загрузки. Имена пользователей и группы могут использоваться (и используются kubeadm) для разработки соответствующих политик авторизации для поддержки начальной загрузки кластера.


**Токены учетной записи службы (Service Account)**

Учетная запись службы DKP предоставляет идентификационные данные для процессов, которые выполняются в pod.

Учетные записи служб обычно создаются автоматически сервером API и связываются с pods, работающими в кластере, через контроллер доступа **ServiceAccount**. Токены на предъявителя монтируются в pods в хорошо известных местах и позволяют процессам внутри кластера взаимодействовать с сервером API. Учетные записи могут быть явно связаны с pods, используя **serviceAccountName** поле **PodSpec**.

~~~

apiVersion: apps/v1 # this apiVersion is relevant as of Kubernetes 1.9
kind: Deployment
metadata:
name: nginx-deployment
namespace: default
spec:
replicas: 3
template:
metadata:
# ...
spec:
serviceAccountName: bob-the-bot
containers:
- name: nginx
image: nginx:1.14.2

~~~

Токены на предъявителя учетной записи службы вполне допустимы для использования вне кластера и могут использоваться для создания удостоверений для давно существующих заданий, которые хотят общаться с API DKP.

1. Чтобы вручную создать учетную запись службы, используйте `kubectl create serviceaccount (NAME)` команду. Это создает учетную запись службы в текущем пространство имен.

~~~

kubectl create serviceaccount jenkins
serviceaccount/jenkins created

~~~

2. Создайте связанный токен:

~~~

kubectl create token jenkins
eyJhbGciOiJSUzI1NiIsImtp...

~~~

Созданный токен является подписанным веб-токеном JSON (JWT).

Подписанный JWT может использоваться в качестве токена на предъявителя для аутентификации в качестве данной учетной записи службы. Обычно эти токены монтируются в pods для доступа к серверу API внутри кластера, но могут использоваться и за пределами кластера.

Учетные записи служб проходят аутентификацию с использованием имени пользователя `system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)` и назначаются группам `system:serviceaccounts` и `system:serviceaccounts:(NAMESPACE)`.

**Примечание:** Поскольку токены учетной записи службы также могут храниться в секретных объектах API, любой пользователь, имеющий доступ на запись к секретам, может запросить токен, и любой пользователь, имеющий доступ на чтение к этим секретам, может аутентифицироваться как учетная запись службы. Будьте осторожны при предоставлении разрешений учетным записям служб и возможностей чтения или записи секретных данных.

**Токены OpenID Connect**

OpenID Connect - это разновидность OAuth2, поддерживаемая некоторыми поставщиками OAuth2. Основным расширением протокола OAuth2 является дополнительное поле, возвращаемое с токеном доступа, называемым ID Token. Этот токен представляет собой веб-токен JSON (JWT) с хорошо известными полями, такими как электронная почта пользователя, подписанный сервером.

Для идентификации пользователя аутентификатор использует id_token (не access_token) из ответа токена OAuth2 в качестве токена-носителя, как представлено на рисунке ниже.

![](resources/30c1d9d9.png)

Рисунок. Токены OpenID Connect

1. Пользователь входит свой провайдер идентификации.

2. Поставщик удостоверений предоставляет `access_token`, `id_token` и `refresh_token`.

3. При использовании **kubectl** используется id_token с `--token` флагом или добавляется непосредственно в `kubeconfig`.

4. **Kubectl** отправляет данные пользователя id_token в заголовке, называемом Авторизация, на сервер API.

5. Сервер API удостоверяется, что подпись JWT действительна, путем сверки с сертификатом, указанным в конфигурации.

6. Сервер API удостоверяется, что id_token срок действия не истек.

7. Сервер API удостоверяется, что пользователь авторизован.

8. После авторизации сервер API возвращает ответ на **kubectl**.

9. **Kubectl** обеспечивает обратную связь с пользователем.

Поскольку все данные, необходимые для подтверждения личности, находятся в id_token, DKP не нужно сообщать поставщику удостоверений. В модели, где каждый запрос не имеет состояния, это обеспечивает очень масштабируемое решение для аутентификации.


#### Подключение по API

Чтобы включить API-плагин, настройте следующие флаги на сервере API:

| Параметр                               | Описание                                                                                                                                                                                                                                                                                                                                                                                                                        | Пример                                                                                                                                        | Обязательность       | 
| :------------------------------------- |:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------| :------------------- |
| `--oidc-issuer-url`                    | URL-адрес поставщика, который позволяет серверу API обнаруживать открытые ключи подписи. используются только URL-адреса вида `https://` . Обычно это URL-адрес обнаружения поставщика без пути, например `https://<account. example.com>` или  `https://<login.example.com>`.  URL должен указывать на уровень ниже `.well-known/openid configuration`                                                                          | Если URL-адрес обнаружения `https://accounts.example.com/.well-known/openid-configuration, значение должно быть https://accounts.exemple.com` | Да  |
| `--oidc-client-id`                     | Идентификатор клиента, для которого должны быть выпущены все токены                                                                                                                                                                                                                                                                                                                                                             | DKP                                                                                                                                       | Да |
| `--oidc-groups-claim`                  | JWT утверждает, что использует его в качестве имени пользователя. По умолчанию предполагается, что `sub` это уникальный идентификатор конечного пользователя. Администраторы могут выбрать другие параметры утверждения, например email или имя, в зависимости от поставщика. Однако утверждения, отличные от email будут иметь префикс с URL-адресом издателя, чтобы предотвратить конфликты имен с другими подключаемыми pods | `sub`                                                                                                                                         | Нет  |
|  `--oidc-groups-prefix`                | Префикс добавляется к групповым утверждениям для предотвращения конфликтов с существующими именами (например, `syste:users`). Например, это значение `oidc:` создаст такие имена групп, как `oidc:engineering` и `oidc:infra`                                                                                                                                                                                                   | `oidc: `                                                                                                                                      |  Нет |
| `--oidc-required-claim`                | Пара ключ=значение, описывающая требуемое утверждение в токене идентификатора. Если установлено, проверяется наличие утверждения в токене идентификатора с совпадающим значением. Повторите этот флаг, чтобы указать несколько утверждений                                                                                                                                                                                      | `claim=value`                                                                                                                                 | Нет  |
|  `--oidc-ca-file`                      | Путь к сертификату центра сертификации, подписавшего веб-сертификат вашего поставщика удостоверений. По умолчанию используются корневые ЦС хоста                                                                                                                                                                                                                                                                                | `/etc/kubernetes/ssl/kc-ca.pem`                                                                                                               |   Нет    |
|  `--oidc-signing-algs`                 | Алгоритмы подписи приняты. По умолчанию `RS256`                                                                                                                                                                                                                                                                                                                                                                                 | `RS512`                                                                                                                                       |   Нет    |

Сервер API можно настроить таким образом, чтобы он доверял только одному эмитенту. Это позволяет использовать общедоступных поставщиков не доверяя учетным данным, выданным третьим лицам. Администраторы, которые хотят использовать несколько клиентов OAuth, должны изучить поставщиков, которые поддерживают azp утверждение (авторизованная сторона) — механизм, позволяющий одному клиенту выпускать токены от имени другого.

DKP не предоставляет поставщика удостоверений OpenID Connect. Используйте существующих поставщиков удостоверений OpenID Connect или запустите свой собственный поставщик удостоверений, например dex , Keycloak , CloudFoundry UAA или OpenUnison от Tremolo Security.

Чтобы поставщик удостоверений работал с DKP, он должен:

1. поддерживать обнаружения подключения OpenID;

2. осуществлять запуск в TLS 1.2 с актуальным шифрованием;

3. иметь сертификат, подписанный ЦС (даже если ЦС не является коммерческим ЦС или является корневым).

**Примечание:** Если развертываете собственного поставщика удостоверений (в отличие от одного из облачных провайдеров), должен быть сертификат веб-сервера поставщика удостоверений, подписанный сертификатом с CA флагом, установленным на **TRUE**, даже если он подписан самостоятельно.

Подключение к DKP по API производится тремя способами:

* инструментом командной строки (kubectl);

* HTTP API с аутентификацией и авторизацией;

* клиентскими библиотеками.

По умолчанию DKP предоставляет свой API через HTTPS, чтобы гарантировать клиентам надежную идентификацию сервера API. Чтобы вызвать этот API, клиентские запросы должны реализовать правильную аутентификацию (authentication and authorization). Существует два основных механизма аутентификации, которые можно использовать для аутентификации сервера API:

* SSL Certificate-based auth;

* Token-based auth.

**Инструмент командной строки (kubectl)**

Подробнее см. в документе «Руководство по системному администрированию» в разделе «Использование kubectl».

**Аутентификация на основе SSL-сертификата**

Первый способ аутентификации запросов API - это использование SSL-сертификатов. Сертификат TLS 1.2 сервера API DKP подписывается Центром сертификации (CA). Все полученные сертификаты являются доверенными сервером API DKP. 

Можно добавить сертификат клиента, который находится в файле `~/.certificate/ca.crt` `curl` командой.

После этого будет получена информация о сертификате клиента в `curl` запросе. При начальной загрузке кластера сертификат также создает пользователя. Этот пользователь получает сертификат, подписанный тем же самым сертификатом. Это происходит потому что, сервер API DKP доверяет центру сертификации и представление такого сертификата пользователю делает его аутентифицированным. Любой пользователь, который представляет действительный сертификат, подписанный центром сертификации кластера, считается аутентифицированным. 

Сертификат клиента будет помещен внутри файла `~/.certificate/profiles/certificate/client.crt`. Закрытый ключ клиента будет находится внутри файла `~/.certificate/profiles/certificate/client.key`. 

Необходимо разместить сертификат клиента и ключ клиента в `curl` запросе для аутентификации на сервере API.

Ниже представлен листинг с настройками аутентификации на основе сертификата, полученного пользователем и подписанный тем же самым сертификатом:

~~~

# ca certificate location
❯❯ cat ~/.certificate/ca.crt | openssl x509 -text
Certificate:
Data:
Version: 3 (0x2)
Serial Number: 1 (0x1)
Signature Algorithm: sha256WithRSAEncryption
Issuer: CN=certificateCA
Validity
Not Before: Jun 16 07:13:11 2022 GMT
Not After : Jun 14 07:13:11 2032 GMT
Subject: CN=certificateCA
Subject Public Key Info:
Public Key Algorithm: rsaEncryption
Public-Key: (2048 bit)

# Расположение клиентского сертификата
❯❯ cat ~/.certificate/profiles/certificate/client.crt | openssl x509 -text
Certificate:
Data:
Version: 3 (0x2)
Serial Number: 2 (0x2)
Signature Algorithm: sha256WithRSAEncryption
Issuer: CN=certificateCA
Validity
Not Before: Jun 16 07:13:12 2022 GMT
Not After : Jun 16 07:13:12 2025 GMT
Subject: O=system:masters, CN=minikube-user
Subject Public Key Info:
Public Key Algorithm: rsaEncryption
Public-Key: (2048 bit)

# client key location
❯❯ ls ~/.certificate/profiles/certificate/client.key
/Users/eranga/.certificate/profiles/certificate/client.key


             
---



# отправьте запрос в API сервер с СА сертификатом, сертификатом и ключом клиента
curl --cacert ~/.certificate/ca.crt \
--cert ~/.certificate/profiles/certificate/client.crt \
--key ~/.certificate/profiles/certificate/client.key \
https://000.000.00.00:0000/apis/apps/v1/deployments

# результат

{
  "kind": "DeploymentList",
  "apiVersion": "apps/v1",
  "metadata": {
    "resourceVersion": "26715"
  },
  "items": [
  --
  --
  ]
}

~~~

**Аутентификация на основе токенов**

Следующий способ аутентификации запросов API заключается в использовании **bearer** заголовка, содержащего действительный токен JWT для учетной записи службы. Как и в случае с пользователями, разные учетные записи служб будут иметь разные уровни доступа. Учетная запись службы имеет токен. Этот токен хранится как secret DKP и может быть прочитан как secret. Этот токен необходимо использовать для аутентификации стороннего приложения на сервере API DKP. В этом сценарии создайте учетную запись службы DKP с именем **bassa-serviceaccount**. Далее определите разрешение на аутентификацию для всего кластера (например, для get, list, watch pods, services, namespaces, deployments, jobs) с помощью **CluserRole**. **ClusterRole** будет присвоено имя учетной записи службы через **ClusterRoleBinding**. Токен внутри учетной записи службы может использоваться для аутентификации/авторизации сервера API. Можно вызывать API-интерфейсы сервера DKP API с помощью этого токена (с **bearer** заголовком) и получить доступ к ресурсам (например, pods, services, namespaces и т.д.).

Ниже приведен способ создания учетной записи службы. Представленная ниже учетная запись службы в пространство имен имеет имя **bassa**. Также представлен токен учетной записи службы, который можно использовать в качестве токена JWT. Токен внутри учетной записи службы может использоваться для доступа к ресурсам всего кластера через службу API, поскольку назначено разрешение для всего кластера с помощью **ClusterRole**.

~~~

apiVersion: v1
kind: ServiceAccount
metadata:
name: bassa-serviceaccount
namespace: bassa

# создайте служебную учетную запись
kubectl apply -f bassa-service-account.yaml

# просмотрите существующие служебные учетные записи для пространства «bassa»
# учетная запись «bassa-serviceaccount» создана
❯❯ kubectl get serviceaccounts -n bassa
NAME                   SECRETS   AGE
bassa-serviceaccount   1         6s
default                1         2m49s

❯❯ kubectl describe serviceaccount bassa-serviceaccount -n bassa
Name:                bassa-serviceaccount
Namespace:           bassa
Labels:              <none>
Annotations:         <none>
Image pull secrets:  <none>
Mountable secrets:   bassa-serviceaccount-token-gmkqk
Tokens:              bassa-serviceaccount-token-gmkqk
Events:              <none>

# токен хранится как секрет, его можно просмотреть по имени токена
# можно использовать как bearer token в запросе
❯❯ kubectl describe secret bassa-serviceaccount-token-gmkqk -n bassa
Name:         bassa-serviceaccount-token-gmkqk
Namespace:    bassa
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: bassa-serviceaccount
              kubernetes.io/service-account.uid: ba741d0a-66bc-43fe-a0ed-94fa71c92e37

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1111 bytes
namespace:  5 bytes
token:      ey----nQ
 # токен приведен для примера

~~~


