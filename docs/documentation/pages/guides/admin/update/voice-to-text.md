Так, ну что, погнали!

Меня зовут Дима Столяров. Я технический директор и основатель Фланта.

Если вы хотите задать мне вопрос, лучше всего сделать это через Twitter. Я решил активно использовать эту платформу.

Также вопросы можно задать в группу фланта в Telegram. Там отвечают мои коллеги, иногда и я.

Недавно мы запустили комьюнити на английском языке для иностранной аудитории. Там больше информации о наших утилитах. Если у вас есть вопросы на английском, вам туда.

Сегодня я расскажу, как обновить Кубернетис. Но сначала — самый простой вопрос и самый простой ответ.

Обновить Кубернетис можно так же, как и любое другое приложение. Однако, если вы не художник, то столкнётесь с определёнными трудностями.

Несмотря на то, что в Кубернетис всё продумано, существует несколько способов обновления. Согласно опросу в Twitter, большинство людей обновляют Кубернетис через создание нового кластера рядом с новой версией и переезд приложения туда. Старые кластеры при этом удаляются.

С точки зрения удобства и простоты обновления, второй способ не самый лучший, так как в Кубернетис есть все необходимые инструменты для обновления без каких-либо проблем.

Но вот статистику не попали те люди, которые ответили «Нет, мы не обновляем».

Есть интересный вопрос: «Вы автообновляете кубернеты?» с вариантами ответа: «Да, только патч релиза», «Да, 16.7.116.8 и выше» или «Иначе и минорам 16.7.117 или…».

Я думаю, вы знаете, как интерпретировать «попкорн» в данной ситуации. По факту людей, которые обновляют кубы, очень мало — 10 процентов.

Если мы посмотрим анонс Куба 19, то увидим, что окно поддержки увеличено с 9 месяцев до года. Поддержка подразумевает, что версии, выпущенные последние 9 месяцев, активно обновляются, в них приходят активные фикс-патчи, портится важные изменения. Это связано с тем, что людям действительно тяжело обновляться. Люди застревают на старых версиях.

В Твиттере и в гифках мы ищем ответ на вопрос, почему так происходит.

Обновление — сложный процесс, и если вы не понимаете, что происходит, то вот обновление.

Куба выглядит как некая форма магии, и кажется, что повторить это невозможно. Но на самом деле всё продумано и основано на законах физики.

Цель моего доклада — показать, что в обновлении Кубы нет ничего сверхъестественного. Важно обновить его без простоя и с возможностью отката.

Вопрос о том, как обновить Кубу, может быть поставлен неправильно. Правильно задавать вопрос о том, как безопасно обновить Кубу без простоя и с возможностью отката.

Прежде всего, нужно понимать, что такое простой. Простой может быть только самого Куба или всего нашего приложения. В любом случае, лучше обновлять Кубу без простоя каких-либо компонентов.

Обновление Куба без простоя кластеров приложения с возможностью отката — вот как должен звучать вопрос.

Доклад о том, как обновлять Кубы, будет продолжен. Но прежде чем я продолжу, хочу сделать рекламную паузу. Мы недавно запустили услугу «Менеджмент кубов».

Теперь о том, что такого особенного в обновлении Куба. Самое страшное в процессе любого обновления — это потенциальная несовместимость.

Несовместимость может быть в функционале, логике работы программы или формате данных. Новая версия программы может не работать со старыми данными, форматы данных могут оказаться несовместимыми.

Как решать проблемы несовместимости? Нужно писать тесты, покрывать весь функционал тестами и проверять, что с одними и теми же тестами проходят и старая версия, и новая версия.

Версионирование — это один из способов решения проблемы несовместимости. Версионирование позволяет добавлять новые функции, не нарушая работу старых клиентов.

Важно следить за тем, чтобы каждая новая версия была совместима со старой. Это позволит постепенно обновлять программу, не нарушая работу пользователей.

В целом, из всего этого выводится здоровенная таблица, которая описывает, через сколько релизов мы можем вносить изменения в API. Короткий ответ на вопрос, что делать с несовместимостью API, — это версионирование.

Теперь, что касается формата хранения данных, это, пожалуй, самая сложная задача в написании софта. Если мы хотим добавить какие-то возможности или данные, нам нужно сделать это так, чтобы не поломать ничего и иметь возможность откатиться.

Формат хранения данных немного пересекается с форматом обращения к внешнему миру. Когда мы говорим о формате хранения данных, мы обычно имеем в виду миграцию данных и изменение схемы. Есть два способа обновления: с простоем и без простоя.

Если мы хотим обновить версию, мы можем сделать это без простоя, только если изменения обратно совместимы. Это значит, что мы можем менять данные и схему так, чтобы старая версия продолжала работать с новой схемой данных.

Пример: представим, что у нас есть таблица с пользователями. Мы хотим добавить новое поле — «дата рождения». Мы выкатываем новую версию, которая добавляет это поле. Старая версия продолжает работать с новой схемой.

Но что, если мы хотим изменить формат данных? Например, вместо даты рождения мы хотим хранить возраст. Это несовместимое изменение, потому что оно меняет смысл данных. Чтобы сделать это, мы должны выполнить три шага:

1. Выкатить новую версию, которая добавляет поле «возраст».
2. Перестать использовать поле «дата рождения» и начать использовать поле «возраст».
3. Удалить поле «дата рождения».

Только при таком подходе мы гарантируем себе две вещи: отсутствие простоя при обновлении и возможность отката.

В кубе, например, для хранения данных используется формат, который совместим с предыдущими версиями. Это позволяет кубу обновлять версии без простоя и откатов.

Таким образом, чтобы сделать безопасное обновление, мы должны следовать нескольким

**Внутри Куба: структура и проблемы**

В этой части мы рассмотрим, как устроен Куб внутри, чтобы понять, какие проблемы могут возникнуть при несовместимости.

Куб можно представить как файловый сервер, где каждый тип данных хранится в отдельной директории. Объекты могут быть файлами или JSON-файлами. Важно понимать, что это двухуровневое дерево: первый уровень — версии, второй уровень — тип данных.

Мы говорим о дипломанте, который имеет несколько версий. В каждой версии есть дипломант. Все версии связаны между собой, и это одни и те же дипломанты, только представленные по-разному. Куб будет на лету конвертировать данные из формата хранения в формат представления.

Вернёмся к истории с версионированием. У нас есть реплики, подсистемы и три основных метода: Get, Put и Watch. Когда мы говорим Кубу: «Отправь нам апдейты по изменениям какого-то объекта», — он отправляет нам эти изменения.

Контроллеры — это программы, которые читают данные с Куба и записывают их обратно. Они бывают двух типов: одни читают данные и пишут их обратно, другие читают данные с сервера и пишут во внешний мир.

Если мы посмотрим на конкретный пример, то увидим, что пользователь создал дипломант. Куб создаёт реплику с этим дипломантом. Контроллер видит появление дипломанта и создаёт реплику.

Когда появляются подсистемы, контроллер прописывает в них информацию о том, на какую ноду они должны быть запущены. Подсистемы видят появление новых данных и на основе этих кодов создают контейнеры в докере.

После успешного создания контейнеров Куб сообщает об этом подсистеме, которая записывает информацию о статусе создания контейнеров в реплику. Реплика-контроллер видит, что контейнеры успешно запущены, и обновляет статус в реплике.

Пользователь видит в дипломанте информацию о том, что он успешно выкатывает реплики. Так работает взаимодействие компонентов друг с другом.

Теперь рассмотрим, как это работает внутри Куба. Обращение внешнего пользователя к Кубу — это внутренний interaction. Взаимодействие компонентов внутри Куба происходит по тому же самому API.

**Инсталляция Куба и обновление компонентов**

Рассмотрим, как выглядит инсталляция Куба и что нужно сделать для его обновления. У нас есть виртуальная машина, на которой установлен Куб с докером. Куб читает папочку с манифестами.

Вместо того чтобы создавать коды через API, мы можем развернуть Куб

Напоминаю, что вопрос на самом деле заключается в том, как обновлять кластеры без простоя.

Ответ такой же, как и раньше: с одной стороны, в кубе всё сделано для того, чтобы можно было обновлять. Нужно просто взять и обновить.

С другой стороны, минорная версия Куба выходит раз в три месяца, и нужно два раза в месяц делать незначительный апдейт. Раз в три месяца — значительно апдейт. Подготовка такого апдейта может занимать недели или месяцы.

Получается, что нужна группа людей, которая будет занята исключительно подготовкой обновлений.

Реальные проблемы обновления:
1. Рестарт контейнеров до версии 1.16. В этой версии контрольная сумма больше не считается на основании внутренней гошной структурки, а на основании объекта. Это означает, что обновление на 1.16 — это рестарт всех контейнеров.

2. Отключение API. В версии 1.16 отключено много API, и это проблема.

Невозможно отследить используемые версии Pi. Когда мы обновляемся на следующую версию, одна из apix перестаёт работать. Вопрос в том, как найти клиентов, которые пользуются этой версией опеки.

При обновлении на 1.16 нам пришлось проделать много работы, чтобы найти все эти холмы.

В итоге, у нас три реальные проблемы: рестарт контейнеров до 1.16, отключения API в 1.16 и невозможность отследить используемые версии Pi.

Сейчас у нас всего 6 кластеров на версии 1.14, и мы их не будем обновлять. Остальные кластеры обновлены до версии 1.15 или 1.16.

Обновление на 1.16 подразумевает рестарт всех узлов кластера и поиск всех холмов. Это занимает некоторое время, и мы застряли на этом этапе.

Из 150 костеров у нас есть кластеры, созданные в 17 или 16 и успешно обновлённые до 1.16. **Обновление кластера Kubernetes: опыт и практика**

У нас есть кластеры, которые мы называем родовыми и важными. Они отвечают за работу сервисов на железе. За последнее время мы обновили их с версии 1.17 до 1.16, и мы знаем, что скоро они будут обновлены до версии 1.19.

Мы не имеем экспериментальных доказательств того, что куб можно обновлять, но мы можем показать, как это происходит на практике. Мы используем патчи релиза, которые позволяют нам обновлять кластеры автоматически. У нас есть понятие каналов обновления, и наши кластеры разбиты по этим каналам.

Мы загружаем обновления в каналы, и после этого все кластеры обновляются автоматически. Мы уже много раз это делали, и у нас не было ни одного разрыва. У нас очень много мониторинга, как внешнего, так и внутреннего.

Обновление до версии 1.15 было сложным, но сейчас мы ждём последние кластеры. Мы решили пропустить версии 1.17 и 1.18. Версии 1.13, 1.14 и 1.12 мы обновляли напрямую.

Сейчас мы находимся на версии 1.16 и планируем перейти на версию 1.19 без проблем. У нас уже написан код, который позволит нам это сделать.

Через месяц мы планируем массово перейти на версию 1.19, и мы уверены, что это получится без проблем. Дальше мы планируем перейти на версии 1.20 и 1.21, и это тоже должно пройти без проблем.

У нас есть экспериментальное доказательство того, что обновление возможно. Мы провели тестирование на тестовом стенде и уверены в том, что это работает.

В заключение хочу сказать, что мы торгуем менеджементом кластеров Kubernetes и можем сделать это либо в вашей инфраструктуре, либо в облаке, либо вашими руками, либо нашими. Это очень дёшево и классно.

Спасибо за внимание. Меня зовут Дима Сталеров, я технический директор компании «Флант».
