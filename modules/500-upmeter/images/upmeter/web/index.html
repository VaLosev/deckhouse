<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Upmeter</title>

    <!--
      Start the server with the following command (read README.md for more details):
      go run ./cmd/upmeter/ start --origins=1 --db-path=./db-emu-server.db.sqlite
    -->

    <style>
      body > * {
        margin-block-end: 2rem;
      }

      div.up {
        background: hsl(130, 83%, 35%);
        background: linear-gradient(
          0,
          hsla(130, 55%, 45%, 100%) 0,
          hsla(130, 50%, 55%, 60%) 6px,
          hsla(130, 44%, 65%, 50%) 12px,
          hsla(130, 44%, 65%, 100%) 100%
        );
      }

      div.down {
        background: hsl(340, 83%, 35%);
        background: linear-gradient(
          0,
          hsl(340, 74%, 25%) 0%,
          hsl(340, 83%, 45%) 5%,
          hsl(340, 83%, 45%) 95%,
          hsl(340, 74%, 35%) 100%
        );
      }

      div.unknown {
        background: hsl(278, 83%, 35%);
        background: linear-gradient(
          0,
          hsl(278, 74%, 25%) 0%,
          hsl(278, 83%, 45%) 5%,
          hsl(278, 83%, 45%) 95%,
          hsl(278, 74%, 35%) 100%
        );
      }

      div.nodata,
      div.muted {
        background: hsl(0, 0%, 82%);
        background: linear-gradient(
          0,
          hsl(0, 0%, 88%) 0%,
          hsl(0, 0%, 94%) 5px,
          hsl(0, 0%, 94%) 95%,
          hsl(0, 0%, 88%) 100%
        );
      }
    </style>

    <script type="module">
      import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

      // The data
      const GPs = await fetch("/api/probe").then((d) => d.json());
      console.log(GPs);

      var h = d3.scaleLinear().domain([0, 1]).range([0, 100]);
      const ordering = ["nodata", "muted", "unknown", "down", "up"];

      const chartElement = d3.select("#chart");

      function show(data) {
        const gp = chartElement
          .selectAll("div.probe") // , (gp) => gp.group + "/" + gp.probe)
          .data(data)
          .join("div") // , (gp) => gp.group + "/" + gp.probe)
          .attr("class", "probe");

        gp.selectAll("h4").data((gp) => [gp.group + "/" + gp.probe]).join("h4").text((d) => d);

        gp.selectAll("div.range")
          .data((gp) => [gp])
          .join("div")
          .attr("class", "range")
          .selectAll("div.slot")
          .data((gp) => gp.statuses)
          .join("div")
          .attr("class", "slot")
          .style("display", "inline-block")
          .style("border-right", ".5px solid #ffffff33")
          .selectAll("div")
          .data((d, i) => ordering.map((k) => [d[k]]))
          .join("div")
          .style("width", "10px")
          .style("outline-right", "1px solid white")
          .style("outline-offset", "-1px")
          .style("height", (d) => `${h(d)}px`)
          .attr("class", (d, i) => ordering[i]);
      }

      // /api/status/range?from=1723221800&to=1723245800&step=300&group=control-plane&probe=apiserver

      async function getData() {
        const step = 300;
        const range = 6 * 3600; // 6 hours
        const from = Math.round(new Date().valueOf() / 1000) - range;
        const to = Math.round(new Date().valueOf() / 1000);
        const url = (gp) =>
          `/api/status/range?from=${from}&to=${to}&step=${step}&group=${gp.group}&probe=${gp.probe}`;
        const fetchGP = (gp) => fetch(url(gp)).then((d) => d.json());
        const gpStatuses = await Promise.all(GPs.map(fetchGP));

        const data = GPs.map((gp, i) => {
          const groupStatuses = gpStatuses[i].statuses;
          if (!groupStatuses[gp.group]) {
            return null;
          }
          if (!groupStatuses[gp.group][gp.probe]) {
            return null;
          }
          gp.statuses = groupStatuses[gp.group][gp.probe]
            .slice(0, -1)
            .map((d) => ({
              up: d.up / d.slot_size,
              down: d.down / d.slot_size,
              unknown: d.unknown / d.slot_size,
              muted: d.muted / d.slot_size,
              nodata: d.nodata / d.slot_size,
            }));

          return gp;
        }).filter((d) => d);

        return data;
      }

      show(await getData());

      setInterval(async () => {
        show(await getData());
        console.log("Updated");
      }, 5000);
    </script>
  </head>
  <body>
    <h1>Deckhouse Kubernetes Platform Subsystem Availability</h1>
    <pre></pre>
    <div id="chart"></div>
  </body>
</html>
